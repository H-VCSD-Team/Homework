# 시험 정리

and or 연산순위 앞에서부터! (따로 연산순위 없음)

마지막 문제 쫄지 말기

그동안 SW **비약적 발전 못했음**

자동차가 컴퓨터처럼 발전했다면 롤스로이스 개싸게삼

SW특징

비 가시성

SW개발 4단계

분석 설계 구현 테스팅( 무슨 프로세스던지 다 이런 방식을 따름 )

요즘 선호하지 않는 프로그래밍

복잡함, 이해하기 어려움

SW개발 → 실패가 많다. 20년동안 별 차이가 없다

SW실패 이유

1. 비가시성
2. 자동화 어려움
3. 개발자를 갈아넣음

# 소프트웨어 개발 생명주기

주먹구구식

**폭포수** : 분석 설계 구현 테스트 순차적으로 진행함

- 장점
    
    각 단계별로 정형화된 접근
    
    체계적인 문서화 가능
    
    프로젝트 진행 확인
    
- 단점
    
    앞단계 지연이 뒷단계에 미침
    
    고객 요구사항 확인하는데 시간이 많이 걸림
    
- 요구사항 확정되어있고 많이 변하지 않을경우 폭포수 쓰는게 좋음

**에자일 프로셋**

폭포수 개발을 여러번 해서 반복하는것

동작하는 SW를 빠르게 확인하고 다음번에 반영시킬수 있음

자동차 전장 4개월 단위반복

# 요구사항

**정의**

시스템이 제공하는 기능, 하지 말아야 할것

명시적 요구사항, 묵시적 요구사항 2개로 구성되어 있음 → SW 품질과 연관 → 요구사항의 달성 정도

**SRS, SwRS**: software requirement specifiaction 

코딩할때, 테스팅할때 이거보고 개발함( 모든 개발활동의 가이드)

**검증사항**

무결성 : 사용자의 요구사항 명세서에 다 있는지

일관성 : 서로 상충되는 요구사항 없는지

명확성 : 부사를 쓰지 말라( 많이 , 빨리, 적절히 이런거 쓰지 않기)

기능성 : 어떻게보다 무엇에 관점(서비스가 어떤기능 제공할건지)

검증가능성 : 요구사항을 보면 테스트 어떻게 해야할지 떠올라야 한다

추적 가능성: 요구사항 양방향 추적 가능해야함

**sw설계**

아키텍처 설계(상위 설계)

하위설계(상세 설계) -코딩

## ISO 26262

1) **ISO 26262 아키텍처 설계 원칙**

강한 응집력, 낯은 결합력

하나 수정했다고 다른거 수정되지 않게 해야함(모듈 사이에 인터페이스 이썽야 함)

**2) ISO 26262 상세설계원칙**

MISRA C에 있음

# **형상관리** 중요한 개념

baseline

CCB(형상 통제 위원회)

# SW품질

의미 : 요구사항을 얼마나 달성했는지

구분

기능, 비기능 요구사항

제약 요구사항

종류

제품 품질

제품 자체가 가지는 품질

프로세스 품질

제품을 개발하는 과정의 품질

verification & validation → SW 테스트

**Verification vs Validation**

> Verification ( 검증 )
> 

SW요구사항 **명세서**에 따라 만들어지고 있는지 확인

> Validation ( 확인 )
> 

**고객이 실질적으로 의도**한 환경이나 사용 목적에 맞게 만들어지는지 확인

Verification 과 Validation은 명확하게 구분되지 않는다 → SW테스트 라고 함

정적 vs 동적 → SW 실행 여부

정적 : 인스펙션, 워크스루, 데스크체크 정적분석(도구가 자동적으로 함) , 동료검토

동적 : 블랙박스 테스트, 화이트박스 테스트

## 제품 품질 메트릭

규모 지표 종류

라인수

주석비율: 전체중에 주석이 몇 퍼센트인지 → 목표 20%

주석제외 라인 수( NCSS ) non-commenting source code?

함수별 라인 수 →목표 80라인(주석 포함)

순환 복잡도 → 함수당 10

nesting depth (if 안에 if 안에 if 안에 …) → 목표 5이하

기능 커버리지

기능 10개 → 테스트 10개 이상

함수 커버리지 → 통합테스트에서 측정, 목표 100프로

정적분석

misra 룰 위반수 → 0개,  즉 MISRA위반 금지

함수 별로 안에서  다른함수 호출 건수 5

함수 별 호출 될수 있는 건수 7

테스트 목적

결함 발견

자원(사람, 비용) 에 따라 적절히 사용, 무조건 빡세게 하는건 아님

내가 짠 부분의 결함을 다른 사람이 발견하는게 더 쉬움( 테스트는 제 3자가 하는게 젤 효과적 )

테스트 하면 소프트웨어 품질 높아지는가?

수정 후 높아짐

## 테스트 vs 디버깅

**테스트**

결함 발견하는 것

1) re test → 수정한 부분만 테스트함

2) 회귀 테스트 → 수정된 부분을 포함한 전체 부분을 테스트함

- SW수정에 의해 기존에 잘 돌던 부분이 문제생기는걸 확인
- 회귀결함 발생시키는 SW수정의 종류:
    - 새로운 결함의 조치
    - 리팩토링
    - 새로운 기능의 추가/변경
        
        오답) 새로운 테스트 스크립트 추가(X)
        
    

**디버깅** : 발견됨 결함을 수정하는것

# V모델

의미

ISO26262에서  개발 생명 주기와 테스트를 맵핑해둔 모델

V모델 → SW, 시스템, 하드웨어에 다 적용 가능( SW에만 적용하는 개발방식이 아님 )

![DF74974E-4D55-4149-BC83-F7A4FCA08728.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/95c7d4fd-520b-4aa4-9cbf-db7f741fbb52/DF74974E-4D55-4149-BC83-F7A4FCA08728.png)

Test Basis 확인 가능 → 테스트를 하기 위해 참조하는 산출물, 상응하는 개발하는 단계의 산출물

**Test Basis 종류**

- 인수테스트: 요구사항 정의서
- 시스템 테스트: SWrs, 요구사항 분석서
- 통합 테스트: 아키텍처
- 단위테스트: 상세 설계서 + 소스코드

## V모델 테스트 종류**→ 단 통 시 인**💥💥💥💥💥💥💥

1. **단위 테스트**
    - 모듈(소스코드) 하나가 정확히 구현되었는지 확인 ( 결함 확인 X )
    - 개발자가 자신의 코드 테스트, 자신의 코드에 확신을 가짐
    - 테스팅을 단독적으로 실행할 수 있는 환경 필요
    - 스텁(stub): 테스팅 대상 모듈에서 호출하는 모듈 함수 ( 테스팅 모듈로 임의의 return 값 보내줌 )

1. **통합 테스트**
    - 여러 모듈을 통합하여 엉키지 않았는지 아키텍처 테스트
    - 모듈 사이의 interface에 집중
    - 종류
        - Bigbang 기법 : 한꺼번에 통합하여 테스팅
        - TopDown 기법 : 상위 모듈부터 테스트
        - BottomUp 기법 : 하위 모듈부터 테스트

1. **시스템 테스팅**
    - SwRS(요구사항 명세서) 확인
    - 사용자 요구사항 만족 되었는지 검사 ( 기능, 비기능 )
    - 테스팅 형상 테스트 끝날때까지 고정시켜야함( 형상 프리징 )
    - 팀에서 하는 마지막 테스팅
    
2. **인수 테스트**
    - 고객이 테스트함( UAT : User Acceptance Testing ) → 사용자의 실 운영 환경에서 테스트한다
    - 사용자에게 인수되기전 사용자가 테스트함
    - 예) 베타 테스트
    

**좋은 테스트케이스**

결함을 많이 발견하는 테스트케이스!!

자신이 개발한 프로그램을 직접 테스트 하는것은 효과적이지 안흠

**테스트케이스 필수항목**

1. 입력값
2. 테스트절차
3. 목표 출력값

실제 출력값( X) 

동적 **테스트 종류 총 3가지**

1. 블랙박스( 명세기반 ) 테스트
2. 화이트박스 ( 구조기반 ) 테스트
3. 경험기반 테스트

## **BlackBox Test 종류💥💥💥💥💥💥**

2.1 구문 테스팅 (Syntax Testing) 

Input 값을 적합(정상)과 부적합(비정상)을 분류하고 예상되는 결과를 검증

테스트 퍼포먼스 좋음

2.2 동등 분할 (Equivalece Partitioning) , 동치 클래스

구문 테스팅에서 입력값에 정량적인 수치, 범위가 있을때

각 범위의 대표값을 이용하여 테스팅함

즉, 같은 결과값들을 내는 입력값을 분류함

2.3 경계값 분석 ( Boundary Value Analysis )

input값을 경계값으로 설정하여 결과 분석

중간값 보다는 경계값에서 오류가 발생할 확률 높기 때문

※ 동등분할, 경계값 분석은 ISO 26262에서 필수 요구함!!

2.4 페어와이즈

모든 경우의 수 테스트 할수 없을때

테스트 케이스가 최소한 한번씩 조합을 이루게 하여 테스트함

어떤 근거를 가지고 테스트를 간소화 할지

※ MS PICT 도구

[https://github.com/microsoft/pict](https://github.com/microsoft/pict)

2.5 기타

인터페이스 테스트 : ISO26262에서 요구, 인터페이스 오류 검증

백투백 테스트 : ISO26262에서 요구 , 모델기반개발에서 사용

결함주입 테스트 : Safety mechanism이 올바로 작동하는지 확인 위해 결함 주입

에러 추정 테스트 : 과거의 오류를 기반으로 테스트케이스 식별

**기능안전**

사전적 의미 : 안전

실질적 의미 : 안전하지 않은 상태가 있을수 있으나, 통제 가능하다!

# 화이트 박스 테스트

**종류**

1. 함수 커버리지
    1. iso 26262 통합테스트에서 측정
    2. 테스트한 함수/ 전체 함수

1. 구문 커버리지
    1. 테스트한 문장 수/ “;” 개수

1. 결정( Branch ) 커버리지 → 시험 나옴
    1. 테스트한 decision 수 / 전체 decision 수 * 2
    2. decision 수 = if or elseif 개수

1. 조건 커버리지
    1. 테스트한 condition 수 / 전체 condition 수 * 2

1. ( Condition decision ) 조건 결정 커버리지 (CD 커버리지)
    1. 테스트한 decision + condition 수 / 전체 decision + condition 수

1. MC/DC 커버리지
    1. N( condition 수 ) + 1
    2. 어차피 도구가 계산함( 사람이 하면 실수할 수 있음 )

1. MCC ( 다중 조건 커버리지 )
    1. 2^N
    2. 전수테스트임 

예)

```cpp
if( a > 3 && b == 6 || c > 12 && d < 6){}
```

- branch coverage
    
    1) a=4,b=8,c=15,d=8
    
    T
    
    2) a=2,b=6,cc=3,d=3
    
    F
    
    이므로 branch coverage 100%다 
    
- MC/DC 100%를 위한 테스트 케이스
    
     4+1 = 5개
    

**예) ISO 26262에서 요구하는 Coverage**

1. Statement coverage
2. (Decision) Branch coverage
3. MC/DC coverage

**순환복잡도**

순환 복잡도의 목표 = 10

높아질수록 코드 이해하기 어려워짐

테스트 이해하기 어려워짐

커버리지 높이는거 어려워짐

# 테스트 자동화

착오

테스트 케이스 개발은 사람이 함

테스트 수행을 자동화 하는것이다!!

# TDD ( Test Driven Development )

**장점**

- test목적을 명확히 함
- 지속적인 코드 개선
- 테스트 케이스가 문서 역할 가능

**단점**

- Unit 테스트 이외 다른 테스트는 없다고 생각할 수 있다

# 리스크 기반 테스트

**리스크란**

리스크는 발생하지 않은 것

발생할 수도 있음을 예상함

발생하면 안좋음

**리스크 기반 테스트**

자원이 부족하기 때문에 우선순위 리스크 기반으로 시험순서, 자원배분 정하는것

리스크 관리 프로세스

식별 → 분석 → 계획

# 정적 테스트

SW실행하지 않고 문제점 찾는것

예제 문제) 정적테스트가 아닌것 고르시오

1. SRS
2. 테스트케이스
3. 소스코드
4. 설계서
5. ~~동작하는 SW~~ ( X )

예제 문제) 정적 분석으로 찾을수 있는것

룰 지켰는지

함수간의 의존성 확인

순환복잡도 검증

중복코드가 있는지 확인

함수 라인수

~~커버리지 분석~~ → 화이트박스 , 동적테스트임

무조건 지켜야 하는거

MISRA

## 인스펙션 vs 워크쓰루

진행자 (Moderator) 의 유무

인스펙션이 Moderator 있고 더 빡세게 진행함

**인스팩션 특징**

- 진행자 있음
- 체크리스트, 산출물 사전에 개인별로 검토하고 와서 회의 진행
- 결함발견 목적
- 종합 보고서 제출함 ( ISO 26262 증빙하기 위해 )

**워크스루 특징**

- 개발자 위주 검토
- 인스팩션과 유사하지만, 진행자 없음

# **결함관리**

결함을 찾으면 등록해야함

결함, 새로 추가한 기능, 요청사항을 모으면 이슈